\section{Nand to Tetris and the Hack Architecture}

Nand to Tetris is divided into several sections that can be worked on or skipped more or less independently of each other.
Each section is further removed from the actual hardware than its predecessor. In the beginning, the students create the necessary chips and logic gates, starting with only a nand gate. This section is not part of this thesis at all, but it may be relevant in future additions to the application~\ref{future-work}.
After that, the students will work with assembly language and create an assembler of their own, the generated code of which will target the CPU from the previous section.
The application created as part of this thesis includes an emulator, that is able to run the assembly directly without any further compilation. This allows students to run their assembly code in the same application as their VM code from the later sections.
In the next section, students will work closely with VM bytecode, first by writing a translator from bytecode to assembly, and later by writing a complete game using the high-level programming language that will be implemented in the last section.
In the end, students will create a compiler for a high-level language called Jack, that is part of the course. They will also implement a standard library for this language, that abstracts many of the direct interactions with the platform, such as printing text to the screen.
The last two parts are relevant to this project because students can run both the VM code and their compiled assembly inside the emulator. Furthermore, the main focus of this project is the aforementioned game that is created in Project 9.
It may seem strange to develop a whole new emulator mainly to improve a single one of twelve projects, but that single project is the ``Tetris'' to which the title of the course refers. Even though Project 9 is not the last project, it is still the highlight of the course for many people.
This is illustrated by the fact that nine of the twelve examples listed under the ``Cool Stuff''~\cite{n2tweb} tab on the official website are Jack programs that would qualify as Project 9 solutions.
Therefore, if your goal is to improve the overall student experience, it makes sense to focus on this project in particular.
Despite that, this the emulators created as part of this project may also improve the experience for other projects.~\ref{evaluation}

% \subsection{The sections of Nand to Tetris}
% \begin{itemize}
%   \item Chips und Logic Gates (nicht Teil der Arbeit)
%   \item CPU und Assembly
%   \item Virtuelle Machine
%   \item High level Sprache und Betriebssystem (nicht Teil der Arbeit)
% \end{itemize}

\subsection{The operating principles of the Hack VM}
The simple C program in~\cref{lst:c-add-123} shows how one might write a loop that adds the numbers 1, 2, and 3 together.
In mathematical notation, it would be written as \(\sum_{i=1}^{3}i\).
This program may seem unremarkable at first glance, but it incorporates quite a few important concepts of modern programming languages, such as variables, loops, conditions, and arithmetic operations.
Although the program itself is trivial, its translation into machine code and its execution by the computer is not.
Since machine code is highly dependent on the target architecture, the following section is focused on the hack platform. However, the concepts discussed are important not only for most other VM implementations, but also for machine code generated by a C compiler, for example.
This is especially true for the stack, which is an important concept in almost every existing programming language.

C is an imperative language, which means that we have to tell the computer how to calculate the sum, rather than just telling it what we want. The program begins by declaring two variables, called \(i\) and \(sum\). The former is used to hold the number of iterations performed, while the latter holds the final result, which is the sum of all \(i\) over which we iterated.

\begin{lstlisting}[
  language=C,
  caption={Calculate 1 + 2 + 3 in C},
  label={lst:c-add-123},
  captionpos=b]
  int i = 1;
  int sum = 0;
  while (i <= 3) {
    sum += i;
    i++;
  }
\end{lstlisting}

In order to translate the program above into something that can be interpreted by the Hack VM, one has to first understand the stack.
A stack is an abstract data structure, with only two fundamental operations: push and pop. The push operation adds and element to the top of the stack, while the pop operation removes the element on top. This means that the element which was pushed onto the stack last, is the one to first be removed if a pop is performed. For that reason, the stack model is called last-in-first-out (LIFO)~\cite{nisan2005}.
This model is simple but powerful and allows a very elegant description of calculations.
For example, to perform an addition, first both operands are pushed onto the stack, then the addition instruction pops these two numbers from the stack and pushes the result of the addition onto it instead. This is illustrated in~\cref{fig:stack-add}, where 2 is pushed on top of 1 before adding both. The stack is often represented as growing down, however in the Hack architecture the stack actually grows up, so this representation is more appropriate.
\begin{center}
  \begin{figure}[ht]
    \centering
    \includegraphics[width=14cm]{fig/stack-add.png}
    \caption{Adding 1 and 2 in a stack based VM}
    \label{fig:stack-add}
  \end{figure}
\end{center}

Unlike many other architectures, push and pop in the Hack architecture can also be used to read and write arbitrary memory addresses, so no other memory-related instructions are required. For this reason, they are the only instructions in Hack that can manipulate memory outside the stack.
This is achieved by extending the push and pop instructions with a segment field, which works as an offset that the VM adds to the actual index that follows it. The address to be read from or written to is therefore computed as \(address=offset(segment)+index\).

Only two of the eight possible segments are used in~\cref{lst:hack-bytecode}. The constant segment is different from all the other segments as it does not actually add anything to the index before treating the result as an address, instead it simply pushes the index onto the stack directly without performing any memory read. Obviously this means that the constant segment cannot be used with the pop instruction.
The local offset reads its offset from the first memory cell: \(address=RAM[1]+index\).

With this knowledge the bytecode~\ref{lst:hack-bytecode} becomes readable. It starts by initializing \(i\) and \(sum\) to one and zero respectively, just like the C code~\ref{lst:c-add-123}. Then a label is declared, which is simply a position in the bytecode that can be used as a target for goto instructions.
The loop is implemented between this label and the label on the last line.
It can be divided into three sections. The first performs the exit condition check to determine if the loop body should be executed. To do this, it first puts the value of \(i\) on the stack and then jumps out of the loop if \(\neg(i < 4)\), which is equivalent to \(i > 3\). If the aforementioned check was false, the actual loop body is executed. This means that the actual implementation of a loop condition works the opposite way than the C example, where we enter the loop if the condition was true.
To update \(sum\), the VM loads the current value of \(sum\) onto the stack, then the current value of \(i\), and after adding the two, the result is written back to \(sum\).
Updating \(i\) works basically the same way, but with a constant value of one instead of another local variable being added.
Then we simply jump back to the beginning of the loop, where the next check for the exit condition is performed, and continue this process until that condition is met.

\subsection{Hack Bytecode}
\begin{lstlisting}[
  caption={Calculate 1 + 2 + 3 in the Hack VM},
  label={lst:hack-bytecode},
  captionpos=b]
  // i = 1
  push constant 1
  pop local 0

  // sum = 0
  push constant 0
  pop local 1

  label LOOP_START

  // the Hack bytecode does not have an <= instruction,
  // therefore use i < 4 instead of i <= 3
  push local 0
  push constant 4
  lt
  // if i >= 4 jump out of the loop
  not
  if-goto LOOP_END

  // sum = sum + i
  push local 1
  push local 0
  add
  pop local 1

  // i = i + 1
  push local 0
  push constant 1
  add
  pop local 0

  // jump to the beginning of the loop again
  goto LOOP_START
  label LOOP_END
\end{lstlisting}
