\section {Generelles und Technologien}

\subsection{WebAssembly}

\begin{itemize}
  \item binäres Instruktionsformat für stack basierte VM
  \item effizienter als JS
  \item kein ersatz für JS als Ganzes, sondern nur für rechenintensive teile
  \item compilation target für viele Programmiersprachen wie C/C++ oder Rust
\end{itemize}

WebAssembly (Wasm) ist ein binäres Instruktionsformat für eine Stack-basierte virtuelle Maschine welche in allen modernen Browsern enthalten ist.
Dieses Instruktionsformat wird von verschiedenen Programmiersprachen als kompilierungs Zielsprache genutzt um eine effizientere Alternative zu JavaScript(JS) für die Browserprogrammierung zu bieten.
Wasm ist jedoch kein Ersatz für JavaScript und hat somit keinen direkten Zugriff auf den DOM oder Events, sondern dient dazu besonders rechenintensive Funktionen in einer sonst nativen Programmiersprache wie C/C++ oder Rust zu schreiben.

\subsection{Rust}

\begin{itemize}
  \item Multiparadigmen-Systemprogrammiersprache
  \item Systemprogrammierung sicher und zugänglicher machen
  \item kann zu wasm compilen
  \item kein GC, aber trotzdem automatische Speicherbereinigung zur Compile time
  \item starkes, statisches typsystem inspiert von ML und Haskell
\end{itemize}

Rust ist eine Multiparadigmen-Systemprogrammiersprache welche entwickelt wurde um Systemprogrammierung sicherer und zugänglicher zu machen. Neben der Option zu nativen Maschinencode zu kompilieren, bietet Rust auch die Option Wasm als Zielplattform zu verwenden und kann somit für Browserprogrammierung verwendet werden.
Genau wie C/C++ hat Rust keine Gargabe Collection zur Laufzeit, sondern verlässt sich auf explizite Funktionsaufrufe um Speicher freizugeben, jedoch muss der Programmierer diese Aufrufe nicht selber programmieren, anders als in C oder C++, deren Speichermodell generell als umständlich und fehleranfällig gilt.
Stattdessen fügt der Compiler alle benötigten Aufrufe selbständig ein. Dies ermöglicht Rust die besten Eigenschaften beider Welten zu vereinen. Speicherverwaltung hat keine zusätzlichen Laufzeitkosten, ist aber trotzdem voll automatisch.
Natürlich hat aber auch dieser Ansatz Nachteile. Um es dem Rust Compiler zu ermöglichen allen benutzen Speicher an der korrekten Stelle freizugeben, muss der Programmierer einige Regeln einhalten. Zuweilen werden an manchen Stellen explizite Angaben über die Lebensdauer von Referenzen benötigt, was Rust Code teils aufwendig zu schreiben macht.
Eine weitere wichtige Eigenschaft von Rust ist das sehr starke, von ML und Haskell inspierte, Typsystem, welches es dem Programmierer ermöglicht komplexe Einschränkungen und Möglichkeiten für Typen festzulegen.

\subsection{Die Vorteile von Rust gegenüber JavaScript}

\begin{itemize}
  \item Performance
  \item Stabilität und Zuverlässigkeit durch starkes, statisches Typsystem
  \item Nützliche Sprach features wie: Enums, Pattern Matching und Traits
  \item Gutes tooling: Cargo zum Bauen und Testen in Einem
\end{itemize}

\subsection{Die Vorteile von Rust gegenüber anderen Wasm-Sprachen}

\begin{itemize}
  \item Performance und Bundle size (kein GC, kleine Runtime)
  \item stabiles Ökosystem: wasm-bindgen, web-sys, console\_error\_panic\_hook
  \item stabile Sprache mit gutem Editor support (im Vergleich zu Zig, Nim, ...)
  \item sicherer und praktischer als C/C++
\end{itemize}

\subsection{React.js}

\begin{itemize}
  \item Industrie Vorreiter für dynamische Frontend Entwicklung
  \item Sehr stabil und mature, mit unzähligen resourcen
\end{itemize}

\subsection{Die Vorteile von React.js gegenüber rohem JavaScript}

\begin{itemize}
  \item Componenten architektur vereinfacht Code re-use stark
  \item Einfache, deklarative und effiziente updates für Components
  \item UI = f(state) anstatt imperativer spagetti code
\end{itemize}
